package test.算法;

/**
 * @创建人 zhaojingen
 * @创建时间 2019/8/7
 * @描述
 */
public class PaiXuSuanFa {

    /**
     * 冒泡排序
     * <p>
     * 要点
     * <p>
     * 冒泡排序是一种交换排序。
     * <p>
     * 什么是交换排序呢？
     * <p>
     * 交换排序：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。
     * <p>
     * 算法思想
     * <p>
     * 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
     * <p>
     * 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，故名。
     * <p>
     * 假设有一个大小为 N 的无序序列。冒泡排序就是要每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。
     * <p>
     * 假设有一个无序序列 { 4. 3. 1. 2, 5 }
     * <p>
     * 第一趟排序：通过两两比较，找到第一小的数值 1 ，将其放在序列的第一位。
     * <p>
     * 第二趟排序：通过两两比较，找到第二小的数值 2 ，将其放在序列的第二位。
     * <p>
     * 第三趟排序：通过两两比较，找到第三小的数值 3 ，将其放在序列的第三位。
     * <p>
     * 至此，所有元素已经有序，排序结束。
     * <p>
     * 要将以上流程转化为代码，我们需要像机器一样去思考，不然编译器可看不懂。
     * <p>
     * 假设要对一个大小为 N 的无序序列进行升序排序（即从小到大）。
     * 每趟排序过程中需要通过比较找到第 i 个小的元素。
     * <p>
     * 所以，我们需要一个外部循环，从数组首端(下标 0) 开始，一直扫描到倒数第二个元素（即下标 N - 2) ，剩下最后一个元素，必然为最大。
     * <p>
     * 假设是第 i 趟排序，可知，前 i-1 个元素已经有序。现在要找第 i 个元素，只需从数组末端开始，扫描到第 i 个元素，将它们两两比较即可。
     * <p>
     * 所以，需要一个内部循环，从数组末端开始（下标 N - 1），扫描到 (下标 i + 1)。
     */
    public void bubbleSort(int[] list) {
        int temp = 0; // 用来交换的临时数

        // 要遍历的次数
        for (int i = 0; i < list.length - 1; i++) {
            // 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上
            for (int j = list.length - 1; j > i; j--) {
                // 比较相邻的元素，如果前面的数大于后面的数，则交换
                if (list[j - 1] > list[j]) {
                    temp = list[j - 1];
                    list[j - 1] = list[j];
                    list[j] = temp;
                }
            }

            System.out.format("第 %d 趟：\t", i);
            System.out.println(list.toString());
        }
    }

    /**
     * 对冒泡排序常见的改进方法是加入标志性变量 exchange，用于标志某一趟排序过程中是否有数据交换。
     * <p>
     * 如果进行某一趟排序时并没有进行数据交换，则说明所有数据已经有序，可立即结束排序，避免不必要的比较过程。
     */
    // 对 bubbleSort 的优化算法
    public void bubbleSort_2(int[] list) {
        int temp = 0; // 用来交换的临时数
        boolean bChange = false; // 交换标志

        // 要遍历的次数
        for (int i = 0; i < list.length - 1; i++) {
            bChange = false;
            // 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上
            for (int j = list.length - 1; j > i; j--) {
                // 比较相邻的元素，如果前面的数大于后面的数，则交换
                if (list[j - 1] > list[j]) {
                    temp = list[j - 1];
                    list[j - 1] = list[j];
                    list[j] = temp;
                    bChange = true;
                }
            }

            // 如果标志为false，说明本轮遍历没有交换，已经是有序数列，可以结束排序
            if (false == bChange) {
                break;
            }

            System.out.format("第 %d 趟：\t", i);
            System.out.println(list.toString());
        }
    }
    /**
     * 时间复杂度
     *
     * 若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值：Cmin = N - 1, Mmin = 0。所以，冒泡排序最好时间复杂度为 O(N)。
     *
     * 若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
     * Cmax = N(N-1)/2 = O(N2)
     * Mmax = 3N(N-1)/2 = O(N2)
     *
     * 冒泡排序的最坏时间复杂度为 O(N2)。因此，冒泡排序的平均时间复杂度为 O(N2)。
     *
     * 总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。
     *
     * 算法稳定性
     *
     * 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。
     *
     * 所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。
     */
    /**
     * 快速排序
     * <p>
     * 要点
     * <p>
     * 快速排序是一种交换排序。
     * <p>
     * 快速排序由 C. A. R. Hoare 在 1962 年提出。
     * <p>
     * 算法思想
     * <p>
     * 它的基本思想是：
     * <p>
     * 通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。
     * <p>
     * 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
     * <p>
     * 初始状态为一组无序的数组：2、4、5、1、3。
     * <p>
     * 经过以上操作步骤后，完成了第一次的排序，得到新的数组：1、2、5、4、3。
     * <p>
     * <p>
     * 新的数组中，以 2 为分割点，左边都是比 2 小的数，右边都是比 2 大的数。
     * <p>
     * 因为 2 已经在数组中找到了合适的位置，所以不用再动。
     * <p>
     * 2 左边的数组只有一个元素 1，所以显然不用再排序，位置也被确定。（注：这种情况时，left 指针和 right 指针显然是重合的。因此在代码中，我们可以通过设置判定条件 left 必须小于 right，如果不满足，则不用排序了）。
     * <p>
     * 而对于 2 右边的数组 5、4、3，设置 left 指向 5，right 指向 3，开始继续重复图中的一、二、三、四步骤，对新的数组进行排序。
     */

    public int division(int[] list, int left, int right) {
        // 以最左边的数(left)为基准
        int base = list[left];
        while (left < right) {
            // 从序列右端开始，向左遍历，直到找到小于base的数
            while (left < right && list[right] >= base) {
                right--;
                // 找到了比base小的元素，将这个元素放到最左边的位置
                list[left] = list[right];
            }

            // 从序列左端开始，向右遍历，直到找到大于base的数
            while (left < right && list[left] <= base) {
                left++;
                // 找到了比base大的元素，将这个元素放到最右边的位置
                list[right] = list[left];
            }
        }

        // 最后将base放到left位置。此时，left位置的左侧数值应该都比left小；
        // 而left位置的右侧数值应该都比left大。
        list[left] = base;
        return left;
    }

    private void quickSort(int[] list, int left, int right) {

        // 左下标一定小于右下标，否则就越界了
        if (left < right) {
            // 对数组进行分割，取出下次分割的基准标号
            int base = division(list, left, right);

            System.out.format("base = %d:\t", list[base]);
            System.out.format("%s,%s,%s", list, left, right);
            // 对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序
            quickSort(list, left, base - 1);

            // 对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序
            quickSort(list, base + 1, right);
        }
    }

    /**
     * 时间复杂度
     *
     * 当数据有序时，以第一个关键字为基准分为两个子序列，前一个子序列为空，此时执行效率最差。
     *
     * 而当数据随机分布时，以第一个关键字为基准分为两个子序列，两个子序列的元素个数接近相等，此时执行效率最好。
     *
     * 所以，数据越随机分布时，快速排序性能越好；数据越接近有序，快速排序性能越差。
     *
     * 空间复杂度
     *
     * 快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要 Nlog2N 次的分割处理，所以占用空间也是 Nlog2N 个。
     *
     * 算法稳定性
     *
     * 在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。
     */

    /**
     * 插入排序
     * <p>
     * 要点
     * <p>
     * 直接插入排序是一种最简单的插入排序。
     * <p>
     * 插入排序：每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，知道全部插入完成。
     * <p>
     * 算法思想
     * <p>
     * 在讲解直接插入排序之前，先让我们脑补一下我们打牌的过程。
     * <p>
     * 先拿一张 5 在手里，
     * 再摸到一张 4，比 5 小，插到 5 前面，
     * 摸到一张 6，嗯，比 5 大，插到 5 后面，
     * 摸到一张 8，比 6 大，插到 6 后面，
     * 。。。
     * 最后一看，我靠，凑到的居然是同花顺，这下牛逼大了。
     * <p>
     * 以上的过程，其实就是典型的直接插入排序，每次将一个新数据插入到有序队列中的合适位置里。
     * <p>
     * 很简单吧，接下来，我们要将这个算法转化为编程语言。
     * 假设有一组无序序列 R0, R1, … , RN-1。
     * <p>
     * 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。
     * 然后，我们要依次把 R1, R2, … , RN-1 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 N-1 。
     * <p>
     * 接下来描述插入过程。假设这是要将 Ri 插入到前面有序的序列中。由前面所述，我们可知，插入 Ri 时，前 i-1 个数肯定已经是有序了。
     * <p>
     * 所以我们需要将 Ri 和 R0 ~ Ri-1 进行比较，确定要插入的合适位置。这就需要一个内部循环，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。
     */

    public void insertSort(int[] list) {
        // 打印第一个元素
        System.out.format("i = %d:\t", 0);
        System.out.format("%s,%d,%d", list.toString(), 0, 0);

        // 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列
        for (int i = 1; i < list.length; i++) {
            int j = 0;
            int temp = list[i]; // 取出第i个数，和前i-1个数比较后，插入合适位置

            // 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位
            for (j = i - 1; j >= 0 && temp < list[j]; j--) {
                list[j + 1] = list[j];
            }
            list[j + 1] = temp;

            System.out.format("i = %d:\t", i);
            System.out.format("%s,%d,%d", list.toString(), 0, i);
        }
    }

/**
 * 时间复杂度
 *
 * 当数据正序时，执行效率最好，每次插入都不用移动前面的元素，时间复杂度为 O(N)。
 *
 * 当数据反序时，执行效率最差，每次插入都要前面的元素后移，时间复杂度为 O(N2)。
 *
 * 所以，数据越接近正序，直接插入排序的算法性能越好。
 *
 * 空间复杂度
 *
 * 由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 1 。
 *
 * 算法稳定性
 *
 * 直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是稳定的算法。
 */

    /**
     * 希尔排序
     * <p>
     * 要点
     * <p>
     * 希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版。
     * <p>
     * 该方法因 DL．Shell 于 1959 年提出而得名。
     * <p>
     * 算法思想
     * <p>
     * 希尔排序的基本思想是：
     * <p>
     * 把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。
     * <p>
     * 随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。
     * 我们来通过演示图，更深入的理解一下这个过程。
     * <p>
     * <p>
     * <p>
     * 在上面这幅图中：
     * <p>
     * 初始时，有一个大小为 10 的无序序列。
     * <p>
     * 在第一趟排序中，我们不妨设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。
     * <p>
     * 接下来，按照直接插入排序的方法对每个组进行排序。
     * <p>
     * 在** 第二趟排序中**，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。
     * <p>
     * 按照直接插入排序的方法对每个组进行排序。
     * <p>
     * 在第三趟排序中，再次把 gap 缩小一半，即 gap3 = gap2 / 2 = 1。这样相隔距离为 1 的元素组成一组，即只有一组。
     * <p>
     * 按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。
     * 需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。
     * <p>
     * 所以，希尔排序是不稳定的算法。
     */

    public void shellSort(int[] list) {
        int gap = list.length / 2;

        while (1 <= gap) {
            // 把距离为 gap 的元素编为一个组，扫描所有组
            for (int i = gap; i < list.length; i++) {
                int j = 0;
                int temp = list[i];

                // 对距离为 gap 的元素组进行排序
                for (j = i - gap; j >= 0 && temp < list[j]; j = j - gap) {
                    list[j + gap] = list[j];
                }
                list[j + gap] = temp;
            }

            System.out.format("gap = %d:\t", gap);
            System.out.println(list.toString());
            gap = gap / 2; // 减小增量
        }
    }

    /**
     * 时间复杂度
     *
     * 步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。
     *
     * 算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为插入排序，这就保证了数据一定会被排序。
     *
     * Donald Shell 最初建议步长选择为 N/2 并且对步长取半直到步长达到 1。虽然这样取可以比 O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。
     *
     * 比如，如果一个数列以步长 5 进行了排序然后再以步长 3 进行排序，那么该数列不仅是以步长 3 有序，而且是以步长 5 有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。
     *
     * 已知的最好步长序列是由 Sedgewick 提出的(1, 5, 19, 41, 109,…)，该序列的项来自这两个算式。
     *
     * 这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。
     *
     * 算法稳定性
     *
     * 由上文的希尔排序算法演示图即可知，希尔排序中相等数据可能会交换位置，所以希尔排序是不稳定的算法。
     */
    /**
     * 简单选择排序
     *
     * 要点
     *
     * 简单选择排序是一种选择排序。
     *
     * 选择排序：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。
     *
     * 算法思想
     *
     * 从待排序序列中，找到关键字最小的元素；
     *
     * 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；
     *
     * 从余下的 N - 1 个元素中，找出关键字最小的元素，重复 1、2 步，直到排序结束。
     *
     * 如图所示，每趟排序中，将当前**第 i 小的元素放在位置 i **上。
     */



}
